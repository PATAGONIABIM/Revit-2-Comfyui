#include "WabiSabiKernels.cuh"
#include <cuda_runtime.h>
#include <device_launch_parameters.h>
#include <float.h>

#define MAX_CATEGORIES 256

// ======================================================================================
// FUNCIONES HELPER PARA OPERACIONES CON float3
// ======================================================================================

__device__ float3 operator-(const float3& a, const float3& b) {
    return make_float3(a.x - b.x, a.y - b.y, a.z - b.z);
}

__device__ float3 operator*(float s, const float3& v) {
    return make_float3(s * v.x, s * v.y, s * v.z);
}

__device__ float3 operator+(const float3& a, const float3& b) {
    return make_float3(a.x + b.x, a.y + b.y, a.z + b.z);
}

__device__ float dot(const float3& a, const float3& b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

__device__ float3 cross(const float3& a, const float3& b) {
    return make_float3(
        a.y * b.z - a.z * b.y,
        a.z * b.x - a.x * b.z,
        a.x * b.y - a.y * b.x
    );
}

__device__ float3 normalize(const float3& v) {
    float len = sqrtf(v.x * v.x + v.y * v.y + v.z * v.z);
    if (len > 0) {
        float invLen = 1.0f / len;
        return make_float3(v.x * invLen, v.y * invLen, v.z * invLen);
    }
    return v;
}

// ======================================================================================
// INTERSECCIÓN RAYO-TRIÁNGULO (Möller-Trumbore)
// ======================================================================================

__device__ float rayTriangleIntersect(
    const float3& origin,
    const float3& direction,
    const float3& v0,
    const float3& v1,
    const float3& v2)
{
    const float EPSILON = 0.0000001f;
    float3 edge1 = v1 - v0;
    float3 edge2 = v2 - v0;
    float3 h = cross(direction, edge2);
    float a = dot(edge1, h);
    
    if (a > -EPSILON && a < EPSILON)
        return -1.0f;
    
    float f = 1.0f / a;
    float3 s = origin - v0;
    float u = f * dot(s, h);
    
    if (u < 0.0f || u > 1.0f)
        return -1.0f;
    
    float3 q = cross(s, edge1);
    float v = f * dot(direction, q);
    
    if (v < 0.0f || u + v > 1.0f)
        return -1.0f;
    
    float t = f * dot(edge2, q);
    
    if (t > EPSILON)
        return t;
    else
        return -1.0f;
}

// ======================================================================================
// KERNELS DE RENDERIZADO BÁSICO
// ======================================================================================

__global__ void RenderDepthMap(
    const float3* vertices, int vertexCount, const int* triangles, int triangleCount,
    const CameraData camera, const RenderConfig config, float* depthMap)
{
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= config.width || y >= config.height) return;

    float u = (float)x / (config.width - 1);
    float v = (float)y / (config.height - 1);

    float3 rayOrigin = camera.eyePosition;
    float3 rayDir = normalize(camera.lower_left_corner
                             + u * camera.horizontal_vec
                             + v * camera.vertical_vec
                             - rayOrigin);

    float closestT = FLT_MAX;

    for (int i = 0; i < triangleCount; i++) {
        int i0 = triangles[i * 3]; int i1 = triangles[i * 3 + 1]; int i2 = triangles[i * 3 + 2];
        if (i0 >= vertexCount || i1 >= vertexCount || i2 >= vertexCount) continue;
        
        float3 v0 = vertices[i0]; float3 v1 = vertices[i1]; float3 v2 = vertices[i2];
        
        float t = rayTriangleIntersect(rayOrigin, rayDir, v0, v1, v2);
        if (t > 0.0f && t < closestT) {
            closestT = t;
        }
    }
    depthMap[y * config.width + x] = closestT;
}

__global__ void RenderNormalMap(
    const float3* vertices, int vertexCount, const int* triangles, const float3* normals, int triangleCount,
    const CameraData camera, const RenderConfig config, float3* normalMap)
{
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= config.width || y >= config.height) return;
    
    float u = (float)x / (config.width - 1);
    float v = (float)y / (config.height - 1); 

    float3 rayOrigin = camera.eyePosition;
    float3 rayDir = normalize(camera.lower_left_corner 
                             + u * camera.horizontal_vec 
                             + v * camera.vertical_vec 
                             - rayOrigin);

    float closestT = FLT_MAX;
    int hitTriangle = -1;

    for (int i = 0; i < triangleCount; i++) {
        int i0 = triangles[i * 3]; int i1 = triangles[i * 3 + 1]; int i2 = triangles[i * 3 + 2];
        if (i0 >= vertexCount || i1 >= vertexCount || i2 >= vertexCount) continue;
        float3 v0 = vertices[i0]; float3 v1 = vertices[i1]; float3 v2 = vertices[i2];
        float t = rayTriangleIntersect(rayOrigin, rayDir, v0, v1, v2);
        if (t > 0.0f && t < closestT) { closestT = t; hitTriangle = i; }
    }

    float3 normal = make_float3(0.5f, 0.5f, 1.0f); // Color neutro para fondo
    if (hitTriangle >= 0) {
        int i0 = triangles[hitTriangle * 3];
        if (i0 < vertexCount) {
             normal = normalize(normals[i0]);
        }
    }
    normalMap[y * config.width + x] = normal;
}

__global__ void RenderSegmentationMap(
    const float3* vertices, int vertexCount, const int* triangles, const int* categoryIds,
    const float3* categoryColors, int triangleCount, int categoryCount,
    const CameraData camera, const RenderConfig config, float4* segmentationMap)
{
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= config.width || y >= config.height) return;

    float u = (float)x / (config.width - 1);
    float v = (float)y / (config.height - 1);

    float3 rayOrigin = camera.eyePosition;
    float3 rayDir = normalize(camera.lower_left_corner
                             + u * camera.horizontal_vec
                             + v * camera.vertical_vec
                             - rayOrigin);

    float closestT = FLT_MAX;
    int hitCategoryId = -1;

    for (int i = 0; i < triangleCount; i++) {
        int i0 = triangles[i * 3]; int i1 = triangles[i * 3 + 1]; int i2 = triangles[i * 3 + 2];
        if (i0 >= vertexCount || i1 >= vertexCount || i2 >= vertexCount) continue;
        
        float3 v0 = vertices[i0]; float3 v1 = vertices[i1]; float3 v2 = vertices[i2];
        
        float t = rayTriangleIntersect(rayOrigin, rayDir, v0, v1, v2);
        if (t > 0.0f && t < closestT) {
            closestT = t;
            hitCategoryId = categoryIds[i0];
        }
    }

    float4 finalColor = make_float4(0.8f, 0.8f, 0.8f, 1.0f);
    if (hitCategoryId != -1 && hitCategoryId >= 0 && hitCategoryId < categoryCount) {
        float3 catColor = categoryColors[hitCategoryId];
        finalColor = make_float4(catColor.x, catColor.y, catColor.z, 1.0f);
    }
    segmentationMap[y * config.width + x] = finalColor;
}

__global__ void RenderIdMap(
    const float3* vertices, int vertexCount, const int* triangles, 
    const int* elementIds, int triangleCount,
    const CameraData camera, const RenderConfig config, int* idMap)
{
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= config.width || y >= config.height) return;

    float u = (float)x / (config.width - 1);
    float v = (float)y / (config.height - 1);

    float3 rayOrigin = camera.eyePosition;
    float3 rayDir = normalize(camera.lower_left_corner + u * camera.horizontal_vec + v * camera.vertical_vec - rayOrigin);

    float closestT = FLT_MAX;
    int hitTriangle = -1;

    for (int i = 0; i < triangleCount; i++) {
        float t = rayTriangleIntersect(rayOrigin, rayDir, vertices[triangles[i*3]], vertices[triangles[i*3+1]], vertices[triangles[i*3+2]]);
        if (t > 0.0f && t < closestT) {
            closestT = t;
            hitTriangle = i;
        }
    }

    if (hitTriangle >= 0) {
        // Obtenemos el ID del primer vértice del triángulo golpeado
        idMap[y * config.width + x] = elementIds[triangles[hitTriangle * 3]];
    } else {
        idMap[y * config.width + x] = -1; // Fondo
    }
}
// ======================================================================================
// KERNEL REFINADO: DETECCIÓN DE BORDES ADAPTATIVA (ESTILO REVIT)
// ======================================================================================

__global__ void CombinedEdgeDetectionKernel(
    const float3* normalMap,
    const float* depthMap,
    const int* elementIdMap, 
    float* linesMap,
    int width, int height,
    float normalThreshold, 
    float depthThreshold)  
{
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;

    if (x >= width || y >= height) return;

    int idxC = y * width + x;
    
    // Validar bordes estrictamente antes de cualquier cálculo
    if (x < 1 || x >= width - 1 || y < 1 || y >= height - 1) {
        linesMap[idxC] = 1.0f; // Blanco en los bordes
        return;
    }

    float dC = depthMap[idxC];
    int idC = elementIdMap[idxC];

    // Fondo
    if (dC > 10000.0f || idC == -1) { 
        linesMap[idxC] = 1.0f; 
        return; 
    }

    // Índices de vecinos seguros (gracias al chequeo de x/y arriba)
    int idxL = y * width + (x - 1);
    int idxR = y * width + (x + 1);
    int idxD = (y - 1) * width + x;
    int idxU = (y + 1) * width + x;

    // DETECCIÓN POR ID (Bordes de familias de Revit)
    // Usamos una comparación simple pero robusta
    bool idEdge = (idC != elementIdMap[idxL] || idC != elementIdMap[idxR] || 
                   idC != elementIdMap[idxU] || idC != elementIdMap[idxD]);

    if (idEdge) {
        linesMap[idxC] = 0.0f; // Línea negra
        return;
    }

    // --- DETECCIÓN POR PROFUNDIDAD (SILUETAS) ---
    float diffD = (fabsf(dC - depthMap[idxL]) + fabsf(dC - depthMap[idxR])) / dC;
    if (diffD > depthThreshold) {
        linesMap[idxC] = 0.0f;
        return;
    }

    // --- DETECCIÓN POR NORMALES (ARISTAS INTERNAS) ---
    float3 nC = normalMap[idxC];
    float normalGrad = (1.0f - dot(nC, normalMap[idxL])) + (1.0f - dot(nC, normalMap[idxR]));
    
    if (normalGrad > normalThreshold) {
        linesMap[idxC] = 0.0f;
    } else {
        linesMap[idxC] = 1.0f;
    }
}

// ======================================================================================
// FUNCIONES DE LANZAMIENTO (WRAPPERS)
// ======================================================================================

void LaunchDepthKernel(
    const float3* d_vertices, int vertexCount, const int* d_triangles, int triangleCount,
    const CameraData& camera, const RenderConfig& config, float* d_depthMap, cudaStream_t stream)
{
    dim3 blockSize(16, 16);
    dim3 gridSize((config.width + blockSize.x - 1) / blockSize.x, (config.height + blockSize.y - 1) / blockSize.y);
    RenderDepthMap<<<gridSize, blockSize, 0, stream>>>(d_vertices, vertexCount, d_triangles, triangleCount, camera, config, d_depthMap);
}

void LaunchNormalKernel(
    const float3* d_vertices, int vertexCount, const int* d_triangles, const float3* d_normals, int triangleCount,
    const CameraData& camera, const RenderConfig& config, float3* d_normalMap, cudaStream_t stream)
{
    dim3 blockSize(16, 16);
    dim3 gridSize((config.width + blockSize.x - 1) / blockSize.x, (config.height + blockSize.y - 1) / blockSize.y);
    RenderNormalMap<<<gridSize, blockSize, 0, stream>>>(d_vertices, vertexCount, d_triangles, d_normals, triangleCount, camera, config, d_normalMap);
}

void LaunchLinesKernel(
    const float3* d_normalMap,
    const float* d_depthMap,
    const int* d_elementIdMap,
    const RenderConfig& config,
    float* d_linesMap,
    cudaStream_t stream)
{
    dim3 blockSize(16, 16);
    dim3 gridSize((config.width + blockSize.x - 1) / blockSize.x, 
                  (config.height + blockSize.y - 1) / blockSize.y);
    
    // AQUÍ ESTABA EL ERROR: El orden debe ser idéntico al kernel de arriba
    CombinedEdgeDetectionKernel<<<gridSize, blockSize, 0, stream>>>(
        d_normalMap,            // 1
        d_depthMap,             // 2
        d_elementIdMap,         // 3: EL QUE FALTABA O ESTABA DESORDENADO
        d_linesMap,             // 4
        config.width,           // 5
        config.height,          // 6
        config.normalThreshold, // 7
        config.depthThreshold   // 8
    );
}

void LaunchSegmentationKernel(
    const float3* d_vertices, int vertexCount, const int* d_triangles, const int* d_categoryIds,
    const float3* d_categoryColors, int triangleCount, int categoryCount,
    const CameraData& camera, const RenderConfig& config, float4* d_segmentationMap, cudaStream_t stream)
{
    dim3 blockSize(16, 16);
    dim3 gridSize((config.width + blockSize.x - 1) / blockSize.x, (config.height + blockSize.y - 1) / blockSize.y);
    
    RenderSegmentationMap<<<gridSize, blockSize, 0, stream>>>(
        d_vertices, vertexCount, d_triangles, d_categoryIds, d_categoryColors,
        triangleCount, categoryCount, 
        camera, config, d_segmentationMap);
}

void LaunchIdKernel(const float3* d_vertices, int vertexCount, const int* d_triangles, const int* d_elementIds, int triangleCount, const CameraData& camera, const RenderConfig& config, int* d_idMap, cudaStream_t stream) {
    dim3 blockSize(16, 16);
    dim3 gridSize((config.width + blockSize.x - 1) / blockSize.x, (config.height + blockSize.y - 1) / blockSize.y);
    RenderIdMap<<<gridSize, blockSize, 0, stream>>>(d_vertices, vertexCount, d_triangles, d_elementIds, triangleCount, camera, config, d_idMap);
}